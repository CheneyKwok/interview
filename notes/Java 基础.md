# Java 基础

## 面向对象和面向过程的理解和区别

面向过程：一件事该怎么做，注重实现过程，以过程为中心。

- 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，如单片机、嵌入式开发、Linux等一般采用面向过程开发。
- 缺点：没有面对象易维护、易扩展、易复用

面向对象：以对象为中心，只关心怎样使用，不关心具体实现。以封装、继承、多态三大特性来实现。

- 优点：易维护、易复用、易扩展，由于面向对象有分装、继承、多态的特性，可以设计出低耦合的系统，是系统更加灵活、更加易于维护
- 缺点：性能比面向过程低

## 字符型常量和字符串常量的区别

- 形式上：字符型常量是单引号引起的一个字符，字符串常量是双引号一起的多个字符
- 含义上：字符型常量相当于一个整形值(ASCLL值)，可以参加表达式运算，字符串常量代表一个该字符串在内存中存放位置的地址值
- 占用内存大小上：字符常量占 2 个字节，字符串常量占若干个字节

## JDK 和 JRE 的区别

JDK(Java developer's kit) = JRE + 开发工具集(java、javac、javadoc jar...)
JRE(Java runtime environment) = JVM + 核心类库

## Java 是值传递还是引用传递

值传递：指在调用函数时，将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数
引用传递：指在调用函数时即将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改将影响到实际参数

Java 中是值传递，不论是实际参数是基本类型还是引用类型，都是值传递。基本类型则将值复制一份，引用类型则将地址赋值一份传递

## == 和 equals() 区别

== 是判断两个对象的地址是不是相等。基本类型比较的是值，引用类型比较的是内存地址
equals 是判断两个对象是否相等。但是有两种情况：

- 类没有重写 equals() 方法，则调用的是 Object 父类的 equals() 比较的是地址
- 类重写了 equals() 方法，一般是比较内容是否相等

## 为什么重写 equals() 时必须重写 hashCode()

hashCode 可以获取哈希码，也就是散列码，其不具有唯一性，但具离散性。其意义在于进行类似 hashmap 等操作时，加快对象比较的速度，进而加快对象搜索的速度，大大提高效率。

hashCode() 与 equals() 的关系：

- equals() 相等，则 hashcode 一定相同
- hashcode 相同，equals() 不一定相等
- hashcode 不同，equals 一定不同

## Student s = new Student(); 在内存中做了哪些事

- 载入 Student.classs 文件进内存(方法区)
- 在栈内存为 s 开辟空间
- 在堆内存为 Student 对象开辟空间

## 重写和重载的区别

重写：发生在父子类中，方法名、参数列表必须 相同，返回值范围 <= 父类，抛出的异常范围 <= 父类，访问修饰符范围 >= 父类;如果父类方法访问修饰符为 private，在子类不能重写该方法

重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时

## 封装、继承、多态

封装：把一个对象的属性私有化，同时提供一些可以被外界访问属性的方法。
继承：使用已存在的类的定义作为基础建立新类，新类的定义可以增加新的数据或功能，也可以使用父类的功能，且只能继承一个父类。
多态：不同的子类对象调用相同的父类方法，产生不同的执行结果

## String、StringBuffer、StringBuilder 的区别

- 可变性

String 类采用 final 字符数组保存字符串，String 对象是不可变的。

StringBuilder 与 StringBuff 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是用字符数组保存字符串，但是没有 final 修饰，所以这两种对象是可变的

- 线程安全性

String 中对象是不可变的，线程安全

StringBuffer 对方法加了同步锁，是线程安全的，StringBuilder 并没有对方法进行同步锁，所以是非线程安全

- 性能

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象

StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象的引用。StringBuilder 同理

## 接口和抽象类的区别

- 接口的方法默认是 public，JDK 8 以前接口所有方法不能有实现，以后可以有默认实现，抽象类可以有非抽象的方法
- 接口中的实例变量默认是 final 类型，而抽象类不是
- 一个类可以实现多个接口，但最多只能实现一个抽象类
- 一个类要实现接口的话要实现接口所有的方法，而抽象类不一定
- 接口和抽象类都不能实例化
- 抽象类是对类的抽象，是一种模版设计；接口是行为的抽象，是一种行为的规范

## 泛型的理解

泛型是指在声明时将类型参数化，使用或调用时传入具体类型，只在编译阶段有效。

优点：

- 编译时进行类型安全检查
- 避免了类型转换
- 提高代码的通用性

泛型擦除：编译时会将泛型擦除，如果泛型无界，会替换为 Object，如果有界，会替换为边界类型

通配符：表示一种未知的类型

- ? 不确定的类型
- T (type) 表示一种 Java 类型
- K (key) 表示键值中的键
- V (value) 表示键值中的值
- E (element) 表示元素

上界通配符：表示泛型中的参数必须是该类型或其子类
下界通配符：表示泛型中的参数必须是该类型或其父类

泛型不能向上转型，可以通过使用通配符来向上转型

## ArrayList Vs LinkedList

- ArrayList
  - 基于数组，需要连续内存
  - 随机访问快（指下标访问）
  - 尾部插入、删除性能可以，其他部分插入、删除都会移动数据，因此性能会低
  - 可以利用 cpu 缓存的局部性原理，因为数组连续内存空间的特点，可以预读数组内存中的数据块，访问效率更高，而链表因内存不是连续的，不能有效的预读数据
- LinkedList
  - 基于双向链表，无需连续内存
  - 随机访问慢（要沿着链表遍历）
  - 头尾插入性能高，其他部分需要涉及查询，性能一般
  - 占用内存多，链表频繁的插入、删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，也就会造成频繁的 GC

>>
> ArrayList 与 LinkedList 在查询元素时的时间复杂度都是 O(n)

## HashMap

### 底层数据结构，1.7 与 1.8 有何不同

1.7 数组 + 链表，1.8 数组 + （链表 | 红黑树）

### 为何要用红黑树，为何一上来不树化，树化阈值为何是 8，何时树化，何时退化为链表

- 红黑树主要避免 Dos 攻击，防止链表超长时性能下降，树化应当是偶然情况
  - hash 表的查找、更新时间复杂度是 O(1)，而红黑树的查找、更新时间复杂度是 O(log2n)，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表
  - hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表的概率极低，选择 8 就是为了让树化的几率足够小

- 树化两个条件：链表长度超过树化阈值 & 数组容量 >= 64
- 退化情况1：在扩容时如果拆分树时，树元素个数 <= 6，则会退化链表
- 退化情况2：remove 树节点时，如果 root、root 的 右孩子、root 的左孙子有一个为 null，也会退化为链表

### 索引如何计算？hashCode 都有了为何还要提供 hash() 方法？数组的容量为何是 2 的 n 次幂？

- 计算对象的 hashCode，再进行 hash() 二次哈希，最后 & (capacity - 1) 得到索引
- 二次哈希是为了综合高位数据，让哈希值分布更均匀
- 计算索引时，如果是 2 的 n 次幂可以使用位与运算代替取模，效率更高；扩容时 hash & oldCap == 0 时的元素留在原来位置，否则新位置 = 旧位置 + oldCap
- 选择 2 的 n 次幂作为数组容量主要是为了注重计算索引时的效率，之前的三步都是为了配合其的优化手段

### put 方法流程，1.7 与 1.8 有何不同

流程：

1. HashMap 是懒惰创建数组的，首次使用时才创建
2. 计算索引（通下标）
3. 如果桶下标还没人占用，创建 Node 占位返回
4. 如果桶下标已经被占用
   1. 已经是 TreeNode 就走红黑树的添加或更新逻辑
   2. 普通 Node，则走链表的添加或更新逻辑，如果链表过长超过树化阈值，走树化逻辑
5. 返回前检查容量是否超过阈值，一旦超过则进行扩容

不同：

- 链表插入节点时，1.7是头插法，1.8 是尾插法
- 1.7 是 >= 阈值且没有空位时才扩容，而 1.8 是 > 阈值就扩容
- 1.8 在扩容计算 Node 索引时，会优化

### 加载因子为何是 0.75f

- 在空间占用与查询时间之间取得的较好的平衡
- 大于这个值，空间节省了，但链表就会比较长影响性能
- 小于这个值，冲突减少了，但扩容就就会频繁，空间占用多
