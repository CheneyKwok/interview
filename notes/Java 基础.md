# Java 基础

## 面向对象和面向过程的理解和区别

面向过程：一件事该怎么做，注重实现过程，以过程为中心。

- 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，如单片机、嵌入式开发、Linux等一般采用面向过程开发。
- 缺点：没有面对象易维护、易扩展、易复用

面向对象：以对象为中心，只关心怎样使用，不关心具体实现。以封装、继承、多态三大特性来实现。

- 优点：易维护、易复用、易扩展，由于面向对象有分装、继承、多态的特性，可以设计出低耦合的系统，是系统更加灵活、更加易于维护
- 缺点：性能比面向过程低

## 字符型常量和字符串常量的区别

- 形式上：字符型常量是单引号引起的一个字符，字符串常量是双引号一起的多个字符
- 含义上：字符型常量相当于一个整形值(ASCLL值)，可以参加表达式运算，字符串常量代表一个该字符串在内存中存放位置的地址值
- 占用内存大小上：字符常量占 2 个字节，字符串常量占若干个字节

## JDK 和 JRE 的区别

JDK(Java developer's kit) = JRE + 开发工具集(java、javac、javadoc jar...)
JRE(Java runtime environment) = JVM + 核心类库

## Java 是值传递还是引用传递

值传递：指在调用函数时，将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数
引用传递：指在调用函数时即将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改将影响到实际参数

Java 中是值传递，不论是实际参数是基本类型还是引用类型，都是值传递。基本类型则将值复制一份，引用类型则将地址赋值一份传递

## == 和 equals() 区别

== 是判断两个对象的地址是不是相等。基本类型比较的是值，引用类型比较的是内存地址
equals 是判断两个对象是否相等。但是有两种情况：

- 类没有重写 equals() 方法，则调用的是 Object 父类的 equals() 比较的是地址
- 类重写了 equals() 方法，一般是比较内容是否相等

## 为什么重写 equals() 时必须重写 hashCode()

hashCode 可以获取哈希码，也就是散列码，其不具有唯一性，但具离散性。其意义在于进行类似 hashmap 等操作时，加快对象比较的速度，进而加快对象搜索的速度，大大提高效率。

hashCode() 与 equals() 的关系：

- equals() 相等，则 hashcode 一定相同
- hashcode 相同，equals() 不一定相等
- hashcode 不同，equals 一定不同

## Student s = new Student(); 在内存中做了哪些事

- 载入 Student.classs 文件进内存(方法区)
- 在栈栈内存为 s 开辟空间
- 在堆内存为 Student 对象开辟空间
-                                                                                                                                                                                                                                                                  