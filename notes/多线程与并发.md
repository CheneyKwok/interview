# 多线程与并发

## 多线程理解

什么是多线程：多线程指的是在单个程序之中可以同时运行多个线程来执行不同的任务
优点：

- 提高 CPU 资源的利用率
- 提高程序的响应

使用场景：

- 后台任务，例如：定时向大量(100w以上)的用户发送邮件
- 异步处理，例如：发微博哦，记录日志等
- 分布式计算
- tomcat，多个客户端访问一个 web 服务器，把每个请求交给一个 servlet 处理

## Java 内存模型(JMM)

定义: 只是一个抽象的规范，避免不同硬件和操作系统下对内存访问逻辑有所差异带来同一套代码执行不同结果的问题

JMM 关于同步的规定：

1. 线程**解锁**前，必须把共享变量的值重新刷新回主内存当中
2. 线程**加锁**前，必须将主内存中的最新值读到工作内存中
3. 加锁、解锁是同一把锁

JMM 对内存的划分

分为主内存和工作内存

规定变量存储于主内存中，每个线程都有自己的工作内存，线程中保存了自己需要操作的变量的主内存的拷贝副本，对其进行操作后再刷回主内存

每个线程工作内存是独立的，**线程操作数组只能在工作内存中进行，再刷回主内存，所以线程通信德依靠主内存

Java 线程 <----------> 工作内存 <----------> 主内存

## 说说线程的生命周期和状态

![图 1](../.image/203d6d92c9de5b38ab9cbc9b858b9c010f762214604144aea1999c7c23ee8326.png)  

## 什么是线程死锁？如何避免死锁？

定义：线程死锁描述的是这样一种情况：多种线程同时被阻塞，它们中的一个或全部都在等待某个资源被释放，由于线程被无限地阻塞，因此程序不可能正常终止

如线程 A 持有资源 1，线程 B 持有资源 2，它们同时都想申请对方的资源，所以这两个线程就会互相等待进入死锁状态

如何避免死锁：

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 尝试使用带超时的锁，如 lock.tryLock(timeout) 来替代使用内部锁机制
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

## 说说 sleep() 方法和 wait() 方法的区别和共同点

- 两者最主要的区别在于：sleep() 方法没有释放锁，而 wait() 方法释放了锁
- 两者都可以暂停线程的执行
- wait() 通常用于线程间交互/通信，sleep() 通常被用于暂停执行
- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上额 notify() 或者 notifyAll() 方法，或者使用 wait(timeout) 超时后线程会自动苏醒。sleep() 方法执行完成后，线程会自动苏醒
