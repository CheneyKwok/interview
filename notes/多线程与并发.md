# 多线程与并发

## 多线程理解

什么是多线程：多线程指的是在单个程序之中可以同时运行多个线程来执行不同的任务
优点：

- 提高 CPU 资源的利用率
- 提高程序的响应

使用场景：

- 后台任务，例如：定时向大量(100w以上)的用户发送邮件
- 异步处理，例如：发微博哦，记录日志等
- 分布式计算
- tomcat，多个客户端访问一个 web 服务器，把每个请求交给一个 servlet 处理

## Java 内存模型(JMM)

定义: 只是一个抽象的规范，避免不同硬件和操作系统下对内存访问逻辑有所差异带来同一套代码执行不同结果的问题

JMM 关于同步的规定：

1. 线程**解锁**前，必须把共享变量的值重新刷新回主内存当中
2. 线程**加锁**前，必须将主内存中的最新值读到工作内存中
3. 加锁、解锁是同一把锁

JMM 对内存的划分

分为主内存和工作内存

规定变量存储于主内存中，每个线程都有自己的工作内存，线程中保存了自己需要操作的变量的主内存的拷贝副本，对其进行操作后再刷回主内存

每个线程工作内存是独立的，**线程操作数组只能在工作内存中进行，再刷回主内存，所以线程通信德依靠主内存

Java 线程 <----------> 工作内存 <----------> 主内存

## 说说线程的生命周期和状态

![图 1](../.image/203d6d92c9de5b38ab9cbc9b858b9c010f762214604144aea1999c7c23ee8326.png)  

## 什么是线程死锁？如何避免死锁？

定义：线程死锁描述的是这样一种情况：多种线程同时被阻塞，它们中的一个或全部都在等待某个资源被释放，由于线程被无限地阻塞，因此程序不可能正常终止

如线程 A 持有资源 1，线程 B 持有资源 2，它们同时都想申请对方的资源，所以这两个线程就会互相等待进入死锁状态

如何避免死锁：

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 尝试使用带超时的锁，如 lock.tryLock(timeout) 来替代使用内部锁机制
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

## 说说 sleep() 方法和 wait() 方法的区别和共同点

- 两者最主要的区别在于：sleep() 方法没有释放锁，而 wait() 方法释放了锁
- 两者都可以暂停线程的执行
- wait() 通常用于线程间交互/通信，sleep() 通常被用于暂停执行
- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上额 notify() 或者 notifyAll() 方法，或者使用 wait(timeout) 超时后线程会自动苏醒。sleep() 方法执行完成后，线程会自动苏醒

## 无锁、偏向锁、轻量级锁、重量级锁

这四种锁专门针对 synchronized

### 无锁

 无锁对资源不进行锁定，所有线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

 特点是修改操作在循环内进行，线程会不断的尝试修改共享资源，直到修改成功。CAS即无锁的实现。无锁无法全面替代有锁，但在某些场合下无锁的性能非常高

### 偏向锁

偏向锁是指一段同步代码一直被一个线程访问，那么该线程就会自动获取锁，降低获取锁的代价。

线程第一次使用 CAS 将 Mark Word(标记字段)中的线程ID 设置为当前线程ID，在以后进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测对象头中 Mark Word 是否存储指向当前线程的偏向锁。

### 轻量级锁

轻量级锁是指在偏向锁的时候，被其他线程访问，偏向锁就会升级为轻量级锁，其他线程通过自旋的方式尝试获取锁，不会阻塞，从而提高性能

流程：

- 线程的栈帧内创建锁记录对象(Lock Record),拷贝对象头中的 Mark Word 到锁记录中
- CAS 尝试将 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 中的 owner 指针指向对象的 Mark Word
- 另一个来获取锁时，将会自旋等待。当自旋超过一定次数，或者自旋时，又有第三个线程来访问时，轻量级锁升级为重量级锁

### 重量级锁

升级为重量级锁时，Mark word 存储的是指向重量级锁的指针，此时等待锁的进程都会进入阻塞状态
