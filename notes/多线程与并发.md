# 多线程与并发

## 多线程理解

什么是多线程：多线程指的是在单个程序之中可以同时运行多个线程来执行不同的任务
优点：

- 提高 CPU 资源的利用率
- 提高程序的响应

使用场景：

- 后台任务，例如：定时向大量(100w以上)的用户发送邮件
- 异步处理，例如：发微博哦，记录日志等
- 分布式计算
- tomcat，多个客户端访问一个 web 服务器，把每个请求交给一个 servlet 处理

## Java 内存模型(JMM)

定义: 只是一个抽象的规范，避免不同硬件和操作系统下对内存访问逻辑有所差异带来同一套代码执行不同结果的问题

JMM 关于同步的规定：

1. 线程**解锁**前，必须把共享变量的值重新刷新回主内存当中
2. 线程**加锁**前，必须将主内存中的最新值读到工作内存中
3. 加锁、解锁是同一把锁

JMM 对内存的划分

分为主内存和工作内存

规定变量存储于主内存中，每个线程都有自己的工作内存，线程中保存了自己需要操作的变量的主内存的拷贝副本，对其进行操作后再刷回主内存

每个线程工作内存是独立的，**线程操作数组只能在工作内存中进行，再刷回主内存，所以线程通信德依靠主内存

Java 线程 <----------> 工作内存 <----------> 主内存

## 说说线程的生命周期和状态

![图 1](../.image/203d6d92c9de5b38ab9cbc9b858b9c010f762214604144aea1999c7c23ee8326.png)  

## 什么是线程死锁？如何避免死锁？

定义：线程死锁描述的是这样一种情况：多种线程同时被阻塞，它们中的一个或全部都在等待某个资源被释放，由于线程被无限地阻塞，因此程序不可能正常终止

如线程 A 持有资源 1，线程 B 持有资源 2，它们同时都想申请对方的资源，所以这两个线程就会互相等待进入死锁状态

如何避免死锁：

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 尝试使用带超时的锁，如 lock.tryLock(timeout) 来替代使用内部锁机制
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

## 说说 sleep() 方法和 wait() 方法的区别和共同点

- 两者最主要的区别在于：sleep() 方法没有释放锁，而 wait() 方法释放了锁
- 两者都可以暂停线程的执行
- wait() 通常用于线程间交互/通信，sleep() 通常被用于暂停执行
- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法，或者使用 wait(timeout) 超时后线程会自动苏醒。sleep() 方法执行完成后，线程会自动苏醒

## 无锁、偏向锁、轻量级锁、重量级锁

这四种锁专门针对 synchronized

Lock Recor：其包括一个用于存储对象头中的 mark word（官方称之为Displaced Mark Word）以及一个指向对象的指针(Object reference)

### 无锁

 无锁对资源不进行锁定，所有线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

 特点是修改操作在循环内进行，线程会不断的尝试修改共享资源，直到修改成功。CAS即无锁的实现。无锁无法全面替代有锁，但在某些场合下无锁的性能非常高

### 偏向锁

偏向锁是指一段同步代码一直被一个线程访问，那么该线程就会自动获取锁，降低获取锁的代价。

线程第一次使用 CAS 将 Mark Word(标记字段)中的线程ID 设置为当前线程ID，在以后进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测对象头中 Mark Word 是否存储指向当前线程的偏向锁。

- 首先获取锁对象
- 由高到低找到一个空闲的 Lock Record
- 将 Lock Record 的 obj 指向锁对象
- 如果锁对象的 mark word 的状态是偏向模式并且偏向的线程是自己，epoch(类似时间戳)等于 class 的 epoch
- 构建一个偏向当前线程的 mark word
- CAS 替换对象头的 mark word

epoch：epoch 类似一个时间戳，用来表明偏向的合法性。每个 class 会有一个对应的 epoch 字段，每个处于偏向锁状态对象的 mark word  也有该字段，
初始值为创建时 class 中的 epoch 的值。每次发生批量重偏向时，更新 class 中的 epoch,同时遍历 JVM 中所有线程的栈，找到所有处于加锁状态的偏向锁，更新其中的 epoch

### 轻量级锁

轻量级锁是指在线程在获取锁时，锁对象处于偏向模式且偏向的线程还在使用锁，就会将锁的 mark word 改为轻量级锁的状态。
加锁流程：

- 在线程栈中创建一个 Lock Record，将其 obj 字段指向锁对象
- CAS 将锁对象头中的 Mark Word 替换为指向 Lock Record 的指针，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，进入下一步
- 如果是当前线程已经持有该锁，代表这是一次锁重入。设置 Lock Record 的第一部分(Displaced Mark Word) 为 null，起一个重入计数器的作用，然后结束
- 走到这一步说明发生了竞争，需要膨胀为重量级锁。

### 重量级锁

升级为重量级锁时，Mark word 存储的是指向重量级锁的指针，此时等待锁的进程都会进入阻塞状态
